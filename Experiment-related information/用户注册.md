# 用户注册

1.创建用户表



2.注册-持久层  通过MyBatis来操作数据库
2.1 sql语句
1.用户的注册功能

```
```

2.在用户注册时查询当前用户名是否存在，若存在则不能进行注册

`````
`````



2.2 设计接口和抽象方法
定义Mapper接口



3.注册-业务层

3.1 规划异常

1.RuntimeException异常，作为异常的子类，然后再去定义具体的异常类型来继承这个异常，

业务层异常的基类：ServiceException异常继承RuntimeException

2.用户名被占用的异常：UsernameDuplicatedException

3.站在执行数据插入的时候，服务器数据库宕机等的异常：InsertException



3.2 设计接口和抽象方法

1.在service包下创建UserService接口

2.创建实现类UserServiceImpl，实现接口和抽象方法



4.注册-控制层
4.1创建响应
状态码、状态描述信息、数据，封装到一个类中，将这类作为方法返回值，返回给前端浏览器

4.2设计请求

依据当前的业务功能模块
```
请求路径：/user/reg
请求参数：User user
请求类型：POST
响应结果：JsonResult<void>
```

4.3处理请求

1.创建一个控制层对应的类UserController类，依赖于业务层的接口

4.4控制层优化设计

在控制层抽离一个父类，在这个父类中统一去处理关于异常的相关操作，BaseController类



5.注册-前端页面

1.在register页面中编写发送请求的方法，点击事件来完成，选中对应的按钮(\$(“选择器”))，再去添加点击的事件，\$.ajax()函数发送异步请求（异步就是这个旧的页面不会变，只会加载新的布局，不会跳转到新的页面）
2.JQuery封装了函数：\$.ajax()函数,通过对象调用，异步加载请求（依靠的时Javascript提供的一个对象XHR，封装了这个对象）
3.`ajax()` 使用方式。需要传递一个方法体作为方法的参数来使用，一对大括号称之为方法体。`ajaxj` 接收多个参数，参数与参数之间要求使用 “,” 进行分割，每一组参数之间使用 “:” 进行分割，参数的组成部分一个是参数的名称（不能随意的定义），是参数的值，参数的值要求是用字符串来标识。参数的声明顺序没哟要求。语法结构：

`````
方法一
$.ajax(fun());

functioin fun(){
	//TODO
}

方法二
$.ajax({
url:"",
type:"",
data:"",
dataType:"",
success:function(){

},
error:function(){

}
})
`````





| 参数     | 功能描述                                                     |
| -------- | ------------------------------------------------------------ |
| url      | 标识请求的地址(url地址)，不能包含参数列表部分的内容。例如：url: "localhost:8080/users/reg" |
| type     | 请求类型（GET和POST请求的类型）。例如：type: "POST"          |
| data     | 向指定的请求url地址提交的数据。例如：data: "username=tom&pwd=123" |
| dataType | 提交的数据的类型。数据的类型一般指定为json类型。dataType: "json" |
| success  | 当服务器正常响应客户端时，会自动调用success参数的方法，并且将服务器返回的数据以参数的形式传递给这个方法的参数上 |
| error    | 当服务器未正常响应客户端时，会自动调用error参数的方法，并且将服务器返回的数据以参数的形式传递给这个方法的参数上 |

注意 ：js代码可以独立声明在一个js的文件里或声明在script标签中

`````
<!--	ajax代码的编写-->
	<script type="text/javascript">
		//1.监听注册按钮是否被点击，如果被点击可以执行一个方法
		$("#btn-reg").click(function(){
			//动态获取表单中填写的数据
			// let username = $("#username").val();
			// let pwd = $("password").val();
			//console.log($("#form-reg").serialize());
			//发送ajax()的异步请求
			const password = $("input[name='password']").val().trim();
			const confirmPassword = $("input[name='confirmpassword']").val().trim();
			if(password != confirmPassword){
				alert("密码不一致!");
			}else{
				$.ajax({
					url:"/user/reg", //端口号:localhost:9999/ 可以省略
					type:"POST",
					data:$("#form-reg").serialize(),
					dataType:"JSON",
					success:function (json) {
						if(json.state == 200)alert("注册成功");
						else alert("注册失败");
					},
					error:function (xhr) {
						alert("注册时产生未知的错误!" + xhr.status);
					}
				});
			}



		});
`````



用户登录

当用户输入用户名和密码，将数据提交给后台数据库进行查询，如果存在对应的用户名和
密码则表示登陆成功，系统跳转到index.html页面，跳转使用jquery来完成

1.1规划需要执行的 SQL 语句

~~~markdown
依据用户提交的用户名和密码做 select 查询。密码的比较在业务层执行。

```sql
select * from t_user where username=?
~~~

**说明：** 如果在分析过程发现某个功能模块已经被开发完成，所以就可以省略当前的开发步骤，这个分析过程不能够省略。

1.2 接口设计和方法

不用重复开发。单元测试也是无需单独执行了



2. 登录 - 业务层

2.1 规划异常

1. **密码错误异常（PasswordNotMatchException）：**

   - 当用户名对应的密码错误时会触发此异常
   - 这是一个**业务异常**，属于**运行时异常**

2. **用户名不存在异常（UsernameNotFoundException）：**

   - 当查询不到用户名时会触发此异常
   - 这也是一个**业务异常**，属于**运行时异常**

3. **异常的编写要求：**

   - 业务层的异常需要继承自`ServiceException`异常类

   - 在具体的异常类中需要定义构造方法

   - 可以使用快捷键来生成构造方法

   - 提示整个异常类需要有5个构造方法（通常包括无参构造、带异常信息构造、带异常信息和原因构造等）

     

2.2 设计业务层接口和抽象方法的实现

1. 直接在 UserServivce 接口中编写抽象方法，login(String username, String password)。将当前登录成功的用户数据以当前用户对象的形式进行返回。

   状态管理：

   可以将数据保存在 cookie 或者 session 中，可以避免重复度很高的数据多次频繁操作数据进行获取（用户名、用户 id - 存放在 session 中）。

   2. 需要在实现类中实现父接口中抽象方法。

   3. 在测试类中测试业务层登录的方法是否可以执行通过。



3登录-控制层

3.1 处理异常

业务层抛出的异常是什么，需要在统一异常处理类中进行统一的捕获和处理，如果也曾抛出的异常类型已经在统一异常处理类中曾经处理过，则不需要重复添加。

```java
else if(e instanceof UserNotExistException){
            jsonResult.setState(5001);
            jsonResult.setMessage("用户名不存在");
        }else if(e instanceof WrongPasswordException){
            jsonResult.setState(5002);
            jsonResult.setMessage("密码错误");
        }
```

3.2 设计请求

**请求路径：** /users/login
**请求方式：** POST
**请求数据：** String username, String password,HttpSession session
**响应结果：** JsonResult<User>

3.3 处理请求

在UserController类中编写处理请求的方法



4.登录-前端页面

1.在login.html中依据前面设置的请求来发送ajax

2.访问页面进行用户的登录操作

`````
protected final String getidFromSession(HttpSession session){
        return (String)session.getAttribute("id");
    }

    protected final String getusernameFromSession(HttpSession session){
        return (String)session.getAttribute("username");
    }
`````



3.在登录的方法中将数据封装在 session 对象中。服务本身自动创建有 session 对象，已经是一个全局的 session 对象。SpringBoot 直接使用 session 对象，直接将 HttpSession 类型的对象做为请求处理方法的参数，会自动将全局的 session 对象注入到请求处理方法的 session 形参上。